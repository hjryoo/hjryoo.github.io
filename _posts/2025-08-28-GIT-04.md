---
title: "Git Cherry-Pick"
date: 2025-08-28 04:00:00 +0900
categories: [일상, 공부]
tags: [git, github, version-control, collaboration]
---

# Git Cherry-Pick

`git cherry-pick`은 다른 브랜치로부터 **특정 커밋 하나만** 선택적으로 가져와 현재 브랜치에 반영하는 강력한 명령어입니다. 이는 브랜치 전체를 병합하는 `git merge`와 달리, 원하는 커밋의 변경 사항만 "쏙쏙" 골라 복사해오는 것과 같습니다.

### 1. 개념 및 비유

`git cherry-pick`은 브랜치 작업을 병합(merge)하지 않고 특정 커밋 하나만 다른 브랜치로 가져오는 행위입니다. 마치 고객이 프로모션이나 혜택만 챙기는 '체리 피커(Cherry Picker)'처럼, 필요한 특정 커밋만 다른 브랜치로 가져오는 모습이 비슷하다고 하여 이러한 이름이 붙었습니다.

이 기능은 급하게 수정된 사항을 운영(배포) 브랜치에 빠르게 반영해야 하는 상황에서 매우 유용합니다.

### 2. 사용법

명령어는 매우 간단합니다. 현재 브랜치로 가져오고 싶은 커밋의 해시(hash) 값을 지정해주면 됩니다.

```bash
# git log 또는 git graph 등으로 다른 브랜치의 커밋 해시 값을 확인
git log --oneline --graph --all

# 원하는 커밋을 현재 브랜치로 가져오기
git cherry-pick <가져올_커밋의_해시_값>
```

이 명령어를 실행하면, 선택한 커밋의 변경사항이 **새로운 커밋으로** 현재 브랜치에 생성됩니다. 이는 기존 커밋을 삭제하는 `git reset`과는 완전히 다른 동작 방식입니다.

### 3. 주요 특징 및 사용 시점

-   **선택적 변경 사항 복사**: `cherry-pick`은 특정 커밋의 내용만 복사해오기 때문에, 원래 브랜치와 현재 브랜치는 독립적인 관계를 유지합니다. 브랜치 간의 관계를 만들지 않고 단순히 "변경 내용만 가져오는" 방식입니다.

-   **작업 내역 단절**: `cherry-pick`으로 가져온 커밋은 원래 브랜치의 히스토리와 완전히 별개의 기록이 됩니다. 이로 인해 "이 커밋이 원래 어디서 왔는지" 추적하기 어려울 수 있다는 단점이 있습니다.

-   **주요 사용 사례**:
    -   긴급한 버그 수정(Hotfix) 내용을 master 또는 main 브랜치에 빠르게 적용해야 할 때
    -   개발 중인 기능의 일부만 다른 브랜치에 먼저 적용하고 싶을 때

### 4. 충돌(Conflict) 발생 가능성

`cherry-pick`은 현재 브랜치의 코드 상태와 가져올 커밋의 코드 상태가 다를 경우 충돌(Conflict)을 일으킬 수 있습니다. 특히 현재 브랜치가 `cherry-pick` 하려는 커밋보다 더 최신 변경 사항을 가지고 있을 경우 충돌이 발생할 확률이 높습니다.

충돌이 발생하면 다음 두 가지 중 하나를 선택해야 합니다.
1.  **충돌 해결 후 계속 진행**: 코드 충돌을 직접 수정한 뒤, `git add .` 와 `git cherry-pick --continue` 명령어로 작업을 완료합니다.
2.  **작업 취소**: `git cherry-pick --abort` 명령어로 `cherry-pick` 작업을 완전히 취소하고 이전 상태로 돌아갑니다.

### 5. `git pull`과의 차이점

-   **`git cherry-pick`**: 원본 브랜치의 전체 히스토리가 아닌, **단 하나의 커밋**에 대한 변경 사항만 가져옵니다.
-   **`git pull`**: 원격 저장소의 **전체 변경 사항**을 가져와 로컬 브랜치와 동기화(merge 또는 rebase)합니다.

### 결론

`git cherry-pick`은 전체 브랜치를 병합할 필요 없이 특정 변경 사항만 빠르게 가져와야 할 때 매우 유용한 도구입니다. 하지만 이력 관리의 연속성을 해칠 수 있고, 충돌 발생 시 해결 과정이 필요하므로 꼭 필요한 상황에서 신중하게 사용해야 합니다.